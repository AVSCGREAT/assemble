<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assemble</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Hide overflow to prevent scrollbars from layout shifts */
        }
        .assemble-grid { /* Rebranded from discord-grid */
            display: grid;
            grid-template-columns: 72px 240px 1fr; /* Server list, Channel list, Chat area */
            height: 100vh;
        }
        @media (max-width: 768px) {
            .assemble-grid {
                grid-template-columns: 1fr; /* Stack columns on smaller screens */
                grid-template-rows: auto auto 1fr; /* Server, Channel, Chat */
            }
            .sidebar-servers, .sidebar-channels {
                display: none; /* Hidden by default, will be toggled by JS */
            }
            .sidebar-servers.active, .sidebar-channels.active {
                display: block;
                position: absolute;
                z-index: 100;
                height: 100%;
            }
            .sidebar-servers.active {
                width: 72px;
            }
            .sidebar-channels.active {
                width: 240px;
                left: 72px; /* Position next to server sidebar */
            }
            /* Adjust chat area for mobile to stack */
            .chat-area {
                grid-column: 1 / -1;
                grid-row: 3 / -1;
            }
        }

        /* Custom scrollbar styles */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2e3035; /* Darker grey for track */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #42464d; /* Slightly lighter grey for thumb */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #52565d;
        }

        /* Custom styles for chat messages */
        .chat-message-container {
            display: flex;
            align-items: flex-start;
            padding: 8px 16px;
            border-radius: 8px; /* Rounded corners for messages */
        }
        .chat-message-container:hover {
            background-color: #36393f; /* Slightly lighter on hover */
        }
        .message-avatar {
            width: 40px;
            height: 40px;
            min-width: 40px; /* Prevent shrinking */
            min-height: 40px; /* Prevent shrinking */
            border-radius: 50%;
            background-color: #5865f2; /* Assemble brand color for default avatar */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            color: white;
            margin-right: 12px;
        }
        .message-header {
            display: flex;
            align-items: baseline;
        }
        .message-username {
            font-weight: 600;
            color: white;
            margin-right: 8px;
        }
        .message-timestamp {
            font-size: 0.75rem;
            color: #72767d; /* Lighter grey for timestamp */
        }
        .message-content {
            color: #dcddde; /* Off-white for message text */
            word-wrap: break-word; /* Ensure long words wrap */
            overflow-wrap: break-word;
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 1.5rem;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #36393f;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            text-align: center;
            color: white;
            max-width: 400px;
            width: 90%; /* Responsive width */
        }
        .modal-content input {
            background-color: #1e1f22;
            border: 1px solid #42464d;
            color: white;
            padding: 8px;
            border-radius: 4px;
            width: calc(100% - 16px); /* Account for padding */
            margin-bottom: 15px;
            text-align: left; /* Align text left for input */
        }

        .modal-buttons {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 12px;
        }

        .modal-button {
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .modal-button.confirm {
            background-color: #5865f2;
            color: white;
        }

        .modal-button.confirm:hover {
            background-color: #4752c4;
        }

        .modal-button.cancel {
            background-color: #42464d;
            color: white;
        }

        .modal-button.cancel:hover {
            background-color: #52565d;
        }

        /* Unread dot indicator */
        .unread-dot {
            width: 8px;
            height: 8px;
            background-color: #f23f42; /* Assemble red */
            border-radius: 50%;
            margin-left: auto; /* Push to the right */
            margin-right: 4px;
            flex-shrink: 0; /* Prevent shrinking */
        }

        /* Member list sidebar */
        .member-list-sidebar {
            display: none; /* Hidden by default */
            background-color: #2b2d31;
            flex-direction: column;
            padding: 16px;
            min-width: 200px; /* Adjust as needed */
            max-width: 280px;
            overflow-y: auto;
            position: absolute; /* Position over chat area */
            right: 0;
            top: 0;
            height: 100%;
            z-index: 50; /* Above chat but below modals */
            border-left: 1px solid #232428;
        }
        .member-list-sidebar.active {
            display: flex;
        }

        @media (max-width: 768px) {
            .member-list-sidebar {
                width: 100%; /* Full width on mobile */
                max-width: none;
            }
        }

        /* Scroll to bottom button */
        #scrollToBottomBtn {
            position: absolute;
            bottom: 100px; /* Above message input */
            right: 20px;
            background-color: #5865f2;
            color: white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: background-color 0.2s, opacity 0.2s;
            opacity: 0; /* Hidden by default */
            pointer-events: none; /* Do not block events when hidden */
            z-index: 60; /* Above chat content, below modals */
        }
        #scrollToBottomBtn.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #scrollToBottomBtn:hover {
            background-color: #4752c4;
        }

        /* Messages container to display oldest at top */
        #messagesContainer {
            display: flex;
            flex-direction: column; /* Messages flow from top to bottom */
        }

        /* WebRTC video container and controls */
        #videoCallContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 110; /* Above everything else */
            padding: 20px;
        }
        #videoCallContainer.active {
            display: flex;
        }
        #localVideo {
            width: 20%;
            height: 20%;
            position: absolute;
            top: 20px;
            right: 20px;
            border: 2px solid #5865f2;
            border-radius: 8px;
            background-color: #2b2d31;
            transform: scaleX(-1); /* Mirror local video */
            object-fit: cover;
            z-index: 120;
        }
        #remoteVideo {
            width: 80%;
            height: 80%;
            max-width: 900px;
            max-height: 600px;
            border-radius: 8px;
            background-color: #2b2d31;
            object-fit: contain;
            transform: scaleX(-1); /* Mirror remote video */
            z-index: 115;
        }
        #callControls {
            position: absolute;
            bottom: 20px;
            display: flex;
            gap: 15px;
            z-index: 120;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 12px;
        }
        .call-btn {
            background-color: #5865f2;
            color: white;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .call-btn:hover {
            background-color: #4752c4;
        }
        .call-btn.hangup {
            background-color: #f23f42;
        }
        .call-btn.hangup:hover {
            background-color: #cc3135;
        }
        .call-status {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            z-index: 120;
        }
    </style>
</head>
<body class="bg-[#313338] text-white">
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay hidden">
        <i class="fas fa-spinner fa-spin mr-3"></i> Loading...
    </div>

    <!-- Incoming Call Modal -->
    <div id="incomingCallModal" class="modal-overlay hidden">
        <div class="modal-content">
            <p id="incomingCallMessage"></p>
            <div class="modal-buttons">
                <button class="modal-button confirm" id="acceptCallBtn">Accept</button>
                <button class="modal-button cancel" id="declineCallBtn">Decline</button>
            </div>
        </div>
    </div>

    <!-- Main Assemble Grid Layout -->
    <div class="assemble-grid">
        <!-- Server List Sidebar -->
        <div class="sidebar-servers bg-[#1e1f22] p-2 flex flex-col items-center overflow-y-auto rounded-r-lg">
            <div class="server-icon w-12 h-12 bg-[#5865f2] rounded-full flex items-center justify-center text-xl font-bold mb-2 cursor-pointer transition-all duration-200 hover:rounded-xl hover:bg-[#4752c4]" title="Home">
                <i class="fas fa-bars"></i>
            </div>
            <div class="h-0.5 w-8 bg-[#2e3035] rounded-full my-2"></div> <!-- Divider -->

            <!-- Server Icons will be populated by JS from Firestore -->
            <div id="serverIconsContainer"></div>

            <div class="server-icon w-12 h-12 bg-[#36393f] rounded-full flex items-center justify-center text-xl font-bold mb-2 cursor-pointer transition-all duration-200 hover:rounded-xl hover:bg-[#42464d]" title="Add Server" id="addServerBtn">
                <i class="fas fa-plus"></i>
            </div>
            <div class="server-icon w-12 h-12 bg-[#36393f] rounded-full flex items-center justify-center text-xl font-bold mb-2 cursor-pointer transition-all duration-200 hover:rounded-xl hover:bg-[#42464d]" title="Explore Public Servers">
                <i class="fas fa-compass"></i>
            </div>
        </div>

        <!-- Channel List Sidebar -->
        <div class="sidebar-channels bg-[#2b2d31] flex flex-col rounded-r-lg">
            <!-- Channel Header -->
            <div class="channel-header p-4 shadow-sm relative z-10 flex items-center justify-between">
                <h2 class="text-white text-lg font-semibold whitespace-nowrap overflow-hidden text-ellipsis mr-2" id="currentServerName">Select Server</h2>
                <i class="fas fa-chevron-down text-[#dcddde] cursor-pointer"></i>
            </div>

            <!-- Search Bar -->
            <div class="px-3 pb-2">
                <input type="text" placeholder="Find or start a conversation" class="w-full bg-[#1e1f22] text-[#dcddde] px-3 py-1.5 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-[#5865f2] transition duration-200">
            </div>

            <!-- Channel Sections -->
            <div class="flex-grow overflow-y-auto custom-scrollbar pt-2">
                <div class="channel-category px-3 mb-2">
                    <div class="flex items-center justify-between text-[#99aab5] text-xs font-semibold uppercase">
                        TEXT CHANNELS
                        <i class="fas fa-plus text-sm cursor-pointer hover:text-[#dcddde] transition duration-200" id="createChannelBtn"></i>
                    </div>
                    <div class="channel-list mt-1" id="textChannels">
                        <!-- Channels will be populated here by JS -->
                    </div>
                </div>

                <div class="channel-category px-3 mt-4 mb-2">
                    <div class="flex items-center justify-between text-[#99aab5] text-xs font-semibold uppercase">
                        DIRECT MESSAGES
                        <i class="fas fa-plus text-sm"></i>
                    </div>
                    <div class="channel-list mt-1" id="directMessagesList">
                        <!-- Direct Messages will be populated here by JS -->
                    </div>
                </div>

                <div class="channel-category px-3 mt-4 mb-2">
                    <div class="flex items-center justify-between text-[#99aab5] text-xs font-semibold uppercase">
                        VOICE CHANNELS
                        <i class="fas fa-plus text-sm"></i>
                    </div>
                    <div class="channel-list mt-1" id="voiceChannels">
                        <!-- Voice channels (placeholder) -->
                        <div class="channel-item flex items-center p-2 rounded-md text-[#8e9297] hover:bg-[#36393f] hover:text-[#dcddde] cursor-pointer transition duration-200">
                            <i class="fas fa-volume-up mr-2 text-lg"></i>
                            General
                        </div>
                    </div>
                </div>
            </div>

            <!-- User Info Bar -->
            <div class="user-info-bar bg-[#232428] p-2 flex items-center justify-between">
                <div class="flex items-center">
                    <div class="w-8 h-8 rounded-full bg-[#5865f2] flex items-center justify-center text-sm font-bold text-white mr-2" id="currentUserAvatar">
                        JS
                    </div>
                    <div>
                        <div class="text-white text-sm font-semibold whitespace-nowrap overflow-hidden text-ellipsis" id="currentUserNameDisplay">Loading User...</div>
                        <div class="text-[#99aab5] text-xs" id="currentUserIdDisplay">Online</div>
                    </div>
                </div>
                <div class="flex items-center space-x-2">
                    <i class="fas fa-microphone text-[#b9bbbe] hover:text-white cursor-pointer transition duration-200" title="Mute"></i>
                    <i class="fas fa-headphones text-[#b9bbbe] hover:text-white cursor-pointer transition duration-200" title="Deafen"></i>
                    <i class="fas fa-cog text-[#b9bbbe] hover:text-white cursor-pointer transition duration-200" title="User Settings" id="userSettingsBtn"></i>
                </div>
            </div>
        </div>

        <!-- Chat Area -->
        <div class="chat-area bg-[#313338] flex flex-col relative">
            <!-- Chat Header -->
            <div class="chat-header bg-[#313338] p-4 flex items-center border-b border-[#2b2d31] shadow-sm relative z-10">
                <i class="fas fa-hashtag text-[#99aab5] text-xl mr-2" id="chatHeaderIcon"></i>
                <span class="text-white text-lg font-semibold" id="currentChatName">general</span>
                <div class="ml-auto flex items-center space-x-4 text-[#b9bbbe]">
                    <i class="fas fa-thumbtack text-xl cursor-pointer hover:text-white transition duration-200" title="Pinned Messages"></i>
                    <i class="fas fa-video text-xl cursor-pointer hover:text-white transition duration-200" title="Start Video Call" id="startCallBtn"></i> <!-- New Call Button -->
                    <i class="fas fa-user-friends text-xl cursor-pointer hover:text-white transition duration-200" title="Member List" id="memberListToggle"></i>
                    <i class="fas fa-search text-xl cursor-pointer hover:text-white transition duration-200" title="Search"></i>
                    <i class="fas fa-inbox text-xl cursor-pointer hover:text-white transition duration-200" title="Inbox"></i>
                    <i class="fas fa-question-circle text-xl cursor-pointer hover:text-white transition duration-200" title="Help"></i>
                    <!-- Burger icon for mobile -->
                    <i class="fas fa-bars text-xl cursor-pointer hover:text-white transition duration-200 md:hidden" id="mobileMenuToggle"></i>
                </div>
            </div>

            <!-- Messages Container -->
            <div id="messagesContainer" class="flex-grow overflow-y-auto custom-scrollbar p-4">
                <!-- Messages will be loaded here -->
            </div>

            <!-- Scroll to Bottom Button -->
            <div id="scrollToBottomBtn" class="hidden">
                <i class="fas fa-arrow-down"></i>
            </div>

            <!-- Message Input Area -->
            <div class="message-input-area p-4 bg-[#313338] z-10">
                <div class="relative flex items-center bg-[#383a40] rounded-lg p-2">
                    <i class="fas fa-plus-circle text-[#b9bbbe] text-2xl mr-3 cursor-pointer hover:text-white transition duration-200"></i>
                    <textarea id="messageInput" class="flex-grow bg-transparent text-white placeholder-[#8e9297] resize-none overflow-hidden h-6 leading-6 focus:outline-none custom-scrollbar pr-10" placeholder="Message #general" rows="1"></textarea>
                    <i class="fas fa-gift text-[#b9bbbe] text-xl absolute right-20 cursor-pointer hover:text-white transition duration-200" title="Gift Nitro"></i>
                    <i class="fas fa-sticker-m text-[#b9bbbe] text-xl absolute right-12 cursor-pointer hover:text-white transition duration-200" title="Stickers"></i>
                    <i class="fas fa-face-smile text-[#b9bbbe] text-xl absolute right-4 cursor-pointer hover:text-white transition duration-200" title="Pick an Emoji"></i>
                </div>
            </div>
            <!-- Member List Sidebar -->
            <div id="memberListSidebar" class="member-list-sidebar">
                <h3 class="text-white text-md font-semibold mb-4">Members</h3>
                <div id="memberListContent" class="flex flex-col gap-2">
                    <!-- Members will be listed here -->
                </div>
            </div>

            <!-- Video Call Container -->
            <div id="videoCallContainer">
                <div id="callStatusMessage" class="call-status">Connecting...</div>
                <video id="remoteVideo" autoplay playsinline></video>
                <video id="localVideo" muted autoplay playsinline></video>
                <div id="callControls">
                    <button id="toggleMicBtn" class="call-btn"><i class="fas fa-microphone"></i></button>
                    <button id="toggleCameraBtn" class="call-btn"><i class="fas fa-video"></i></button>
                    <button id="hangupBtn" class="call-btn hangup"><i class="fas fa-phone-slash"></i></button>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, query, serverTimestamp, doc, setDoc, getDoc, orderBy, updateDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables for Firebase instances and user data
        let app;
        let db;
        let auth;
        let userId = 'anonymous'; // Default or anonymous ID
        let currentUserName = 'Guest'; // Default name
        let isAuthReady = false;

        // Configuration for Firebase and app ID (provided by Canvas environment)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-assemble-clone';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // DOM elements
        const messagesContainer = document.getElementById('messagesContainer');
        const messageInput = document.getElementById('messageInput');
        const currentUserIdDisplay = document.getElementById('currentUserIdDisplay');
        const currentUserNameDisplay = document.getElementById('currentUserNameDisplay');
        const currentUserAvatarDisplay = document.getElementById('currentUserAvatar');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const serverIconsContainer = document.getElementById('serverIconsContainer');
        const textChannelsContainer = document.getElementById('textChannels');
        const directMessagesList = document.getElementById('directMessagesList');
        const currentServerNameDisplay = document.getElementById('currentServerName');
        const currentChatNameDisplay = document.getElementById('currentChatName');
        const chatHeaderIcon = document.getElementById('chatHeaderIcon');
        const mobileMenuToggle = document.getElementById('mobileMenuToggle');
        const serverSidebar = document.querySelector('.sidebar-servers');
        const channelSidebar = document.querySelector('.sidebar-channels');
        const userSettingsBtn = document.getElementById('userSettingsBtn');
        const createChannelBtn = document.getElementById('createChannelBtn');
        const addServerBtn = document.getElementById('addServerBtn');
        const memberListToggle = document.getElementById('memberListToggle');
        const memberListSidebar = document.getElementById('memberListSidebar');
        const memberListContent = document.getElementById('memberListContent');
        const scrollToBottomBtn = document.getElementById('scrollToBottomBtn');

        // WebRTC elements
        const videoCallContainer = document.getElementById('videoCallContainer');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const startCallBtn = document.getElementById('startCallBtn');
        const toggleMicBtn = document.getElementById('toggleMicBtn');
        const toggleCameraBtn = document.getElementById('toggleCameraBtn');
        const hangupBtn = document.getElementById('hangupBtn');
        const incomingCallModal = document.getElementById('incomingCallModal');
        const incomingCallMessage = document.getElementById('incomingCallMessage');
        const acceptCallBtn = document.getElementById('acceptCallBtn');
        const declineCallBtn = document.getElementById('declineCallBtn');
        const callStatusMessage = document.getElementById('callStatusMessage');

        // WebRTC state
        let peerConnection;
        let localStream;
        let remoteStream;
        let currentCallDocRef = null;
        let currentCallId = null;
        let callUnsubscribe = null;
        let iceCandidatesUnsubscribe = null;


        // State variables for the app
        let activeConversationType = 'channel';
        let activeServerId = null;
        let activeChannelId = null;
        let activeDmRecipientId = null; // userId of the other person in a DM
        let activeDmRecipientName = null; // username of the other person in a DM

        let unreadCounts = {};
        let displayedMessageIds = new Set(); // To track messages already rendered

        // Stores all loaded servers and their channels
        let allServers = {};
        let onlineUsers = {};

        let unsubscribeServers = null;
        let unsubscribeChannels = null;
        let unsubscribeOnlineUsers = null;
        let unsubscribeIncomingCalls = null;


        // --- Utility Functions ---

        // Function to show a custom modal for confirmations/alerts
        function showModal(message, type = 'alert', onConfirm = null, inputOptions = null) {
            const existingModal = document.querySelector('.modal-overlay');
            if (existingModal) existingModal.remove();

            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'modal-overlay';
            modalOverlay.innerHTML = `
                <div class="modal-content">
                    <p>${message}</p>
                    ${inputOptions ? `<input type="${inputOptions.type || 'text'}" id="modalInput" placeholder="${inputOptions.placeholder || ''}" value="${inputOptions.defaultValue || ''}">` : ''}
                    <div class="modal-buttons">
                        ${type === 'confirm' ? `<button class="modal-button cancel" id="modalCancel">Cancel</button>` : ''}
                        <button class="modal-button confirm" id="modalConfirm">OK</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modalOverlay);

            const modalInput = document.getElementById('modalInput');
            if (modalInput) {
                modalInput.focus();
                modalInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('modalConfirm').click();
                    }
                });
            }

            document.getElementById('modalConfirm').onclick = () => {
                const inputValue = modalInput ? modalInput.value : null;
                if (onConfirm) onConfirm(true, inputValue);
                modalOverlay.remove();
            };

            if (type === 'confirm') {
                document.getElementById('modalCancel').onclick = () => {
                    if (onConfirm) onConfirm(false, null);
                    modalOverlay.remove();
                };
            }
        }

        // Function to parse basic markdown
        function parseMarkdown(text) {
            // Bold: **text**
            text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            // Italic: *text*
            text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
            return text;
        }

        // Show/Hide Loading Overlay
        function showLoadingOverlay(message = "Loading...") {
            loadingOverlay.innerHTML = `<i class="fas fa-spinner fa-spin mr-3"></i> ${message}`;
            loadingOverlay.classList.remove('hidden');
        }

        function hideLoadingOverlay() {
            loadingOverlay.classList.add('hidden');
        }

        // Auto-resize textarea
        function autoResizeTextarea() {
            messageInput.style.height = 'auto';
            messageInput.style.height = messageInput.scrollHeight + 'px';
        }

        function clearChatArea() {
            messagesContainer.innerHTML = '<div class="text-center text-[#99aab5] mt-10">Select a server/channel or direct message to start chatting!</div>';
            currentChatNameDisplay.textContent = 'Welcome to Assemble!';
            chatHeaderIcon.className = 'fas fa-info-circle text-[#99aab5] text-xl mr-2';
            messageInput.placeholder = 'Select a chat...';
            displayedMessageIds.clear(); // Clear displayed messages for new chat
        }


        // --- Chat Message Functions ---

        // Function to display messages in the chat
        function displayMessage(message, docId) {
            if (displayedMessageIds.has(docId)) {
                return; // Message already displayed, skip
            }

            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message-container flex items-start py-2 px-4 hover:bg-[#36393f] transition-colors duration-200 rounded-lg';
            messageElement.dataset.messageId = docId; // Store doc ID for tracking

            const avatarChar = message.username ? message.username.charAt(0).toUpperCase() : '?';
            const timestamp = message.timestamp ? new Date(message.timestamp.seconds * 1000).toLocaleString() : 'Just now';
            const parsedContent = parseMarkdown(message.text); // Parse markdown here

            messageElement.innerHTML = `
                <div class="message-avatar w-10 h-10 min-w-[40px] rounded-full bg-[#5865f2] flex items-center justify-center text-sm font-bold text-white mr-3">
                    ${avatarChar}
                </div>
                <div class="flex flex-col flex-grow">
                    <div class="message-header flex items-baseline">
                        <span class="message-username text-white font-semibold text-base mr-2">${message.username || 'Unknown User'}</span>
                        <span class="message-timestamp text-xs text-[#72767d]">${timestamp}</span>
                    </div>
                    <div class="message-content text-[#dcddde] text-sm">${parsedContent}</div>
                </div>
            `;
            messagesContainer.appendChild(messageElement); // Append new messages to the bottom
            displayedMessageIds.add(docId);
        }

        // Function to send a message
        async function sendMessage(text) {
            if (!db || !auth || !isAuthReady) {
                console.error("Firestore or Auth not initialized.");
                showModal("Error: Chat services are not ready. Please wait.", 'alert');
                return;
            }
            if (text.trim() === '') {
                return;
            }

            const messageData = {
                text: text.trim(),
                username: currentUserName,
                userId: userId,
                timestamp: serverTimestamp(),
                type: activeConversationType
            };

            if (activeConversationType === 'channel') {
                if (!activeServerId || !activeChannelId) {
                    showModal("Please select a server and channel to send messages.", 'alert');
                    return;
                }
                messageData.channelId = activeChannelId;
                messageData.serverId = activeServerId;
            } else if (activeConversationType === 'dm' && activeDmRecipientId) {
                messageData.senderId = userId;
                messageData.recipientId = activeDmRecipientId;
            } else {
                console.error("Invalid conversation state for sending message.");
                showModal("Cannot send message: Invalid conversation type or recipient.", 'alert');
                return;
            }

            try {
                const collectionPath = `artifacts/${appId}/public/data/messages`;
                await addDoc(collection(db, collectionPath), messageData);
                messageInput.value = '';
                messageInput.style.height = 'auto';
            } catch (e) {
                console.error("Error adding document: ", e);
                showModal("Failed to send message: " + e.message, 'alert');
            }
        }

        // Function to check if user is scrolled to the bottom of the messages container
        function isUserAtBottom() {
            const threshold = 1;
            return messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight <= threshold;
        }

        // Show/hide scroll to bottom button
        function showScrollToBottomButton() {
            scrollToBottomBtn.classList.add('visible');
            scrollToBottomBtn.classList.remove('hidden');
        }

        function hideScrollToBottomButton() {
            scrollToBottomBtn.classList.remove('visible');
            scrollToBottomBtn.classList.add('hidden');
        }

        // Function to fetch messages for the current channel and server or DM
        let unsubscribeMessages = null;

        function fetchMessages() {
            if (unsubscribeMessages) {
                unsubscribeMessages();
            }

            if (!db || !isAuthReady) {
                console.error("Firestore not initialized for message fetching.");
                return;
            }

            messagesContainer.innerHTML = ''; // Clear only when switching conversations
            displayedMessageIds.clear(); // Reset displayed IDs
            hideScrollToBottomButton(); // Hide on new chat load

            showLoadingOverlay("Loading messages...");

            let messagesRef = collection(db, `artifacts/${appId}/public/data/messages`);
            let messagesQuery;

            if (activeConversationType === 'channel' && activeServerId && activeChannelId) {
                messagesQuery = query(messagesRef); // Filter client-side
            } else if (activeConversationType === 'dm' && activeDmRecipientId) {
                messagesQuery = query(messagesRef); // Filter client-side
            } else {
                hideLoadingOverlay();
                console.warn("No active conversation to fetch messages for.");
                clearChatArea();
                return;
            }

            let initialLoad = true;
            unsubscribeMessages = onSnapshot(messagesQuery, (snapshot) => {
                hideLoadingOverlay();
                const wasAtBottomBeforeUpdate = isUserAtBottom();

                let newMessagesAdded = false;
                snapshot.docChanges().forEach(change => {
                    const message = change.doc.data();
                    const messageId = change.doc.id;

                    // Apply client-side filtering
                    let isRelevant = false;
                    if (activeConversationType === 'channel' && activeServerId && activeChannelId) {
                        isRelevant = message.type === 'channel' && message.serverId === activeServerId && message.channelId === activeChannelId;
                    } else if (activeConversationType === 'dm' && activeDmRecipientId) {
                        isRelevant = message.type === 'dm' &&
                                    ((message.senderId === userId && message.recipientId === activeDmRecipientId) ||
                                     (message.senderId === activeDmRecipientId && message.recipientId === userId));
                    }

                    if (isRelevant) {
                        if (change.type === "added") {
                            // Only add if not already displayed
                            if (!displayedMessageIds.has(messageId)) {
                                displayMessage(message, messageId);
                                newMessagesAdded = true;
                            }
                        } else if (change.type === "modified") {
                            // Find and update existing message element if needed (e.g., edited message)
                            const existingElement = messagesContainer.querySelector(`[data-message-id="${messageId}"]`);
                            if (existingElement) {
                                // For simplicity, just re-render its content
                                const parsedContent = parseMarkdown(message.text);
                                existingElement.querySelector('.message-content').innerHTML = parsedContent;
                            }
                        } else if (change.type === "removed") {
                            // Remove message element
                            const existingElement = messagesContainer.querySelector(`[data-message-id="${messageId}"]`);
                            if (existingElement) {
                                existingElement.remove();
                                displayedMessageIds.delete(messageId);
                            }
                        }
                    }
                });

                // After processing changes, re-sort all displayed messages if needed (less efficient but ensures correct order)
                // A better approach for maintaining order with differential updates would be to insert in sorted position.
                // For now, re-rendering all is simpler given the client-side sorting needs.
                // Re-fetch all relevant messages to ensure proper sorting on the client side after differential updates.
                // This balances real-time additions with correct ordering.
                let currentRelevantMessages = Array.from(messagesContainer.children)
                                                    .map(el => ({
                                                        id: el.dataset.messageId,
                                                        timestamp: { seconds: new Date(el.querySelector('.message-timestamp').textContent).getTime() / 1000 },
                                                        // Note: We don't have full message data here, so client-side re-sort will need full data or just for added messages.
                                                        // A more robust solution would re-fetch and re-render *all* relevant messages from the snapshot, not just `docChanges`.
                                                        // For now, stick to simplified: on initial load, render all. On subsequent updates, only add new.
                                                    }));

                // Initial load: populate all messages and scroll to bottom
                if (initialLoad) {
                    messagesContainer.innerHTML = ''; // Clear for initial full render
                    displayedMessageIds.clear();
                    let allDocs = [];
                    snapshot.forEach(doc => allDocs.push(doc.data()));

                    let relevantInitialMessages = allDocs.filter(msg => {
                        if (activeConversationType === 'channel' && activeServerId && activeChannelId) {
                            return msg.type === 'channel' && msg.serverId === activeServerId && msg.channelId === activeChannelId;
                        } else if (activeConversationType === 'dm' && activeDmRecipientId) {
                            return msg.type === 'dm' &&
                                   ((msg.senderId === userId && msg.recipientId === activeDmRecipientId) ||
                                    (msg.senderId === activeDmRecipientId && msg.recipientId === userId));
                        }
                        return false;
                    });
                    relevantInitialMessages.sort((a, b) => (a.timestamp?.seconds || 0) - (b.timestamp?.seconds || 0));

                    if (relevantInitialMessages.length === 0) {
                        messagesContainer.innerHTML = '<div class="text-center text-[#99aab5] mt-10">No messages yet. Be the first to say something!</div>';
                    } else {
                        relevantInitialMessages.forEach((msg, index) => {
                            displayMessage(msg, snapshot.docs[index].id); // Pass doc.id explicitly for existing messages
                        });
                    }
                    messagesContainer.scrollTop = messagesContainer.scrollHeight; // Always scroll to bottom on initial load
                    initialLoad = false;
                } else if (newMessagesAdded) {
                    // Subsequent updates: only scroll if user was already at the bottom or if they sent a message
                    if (wasAtBottomBeforeUpdate || snapshot.docChanges().some(change => change.type === 'added' && change.doc.data().userId === userId)) {
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        hideScrollToBottomButton();
                    } else {
                        showScrollToBottomButton();
                    }
                }

                // If no messages at all after processing, show empty state
                if (messagesContainer.children.length === 0 && !loadingOverlay.classList.contains('hidden')) {
                     messagesContainer.innerHTML = '<div class="text-center text-[#99aab5] mt-10">No messages yet. Be the first to say something!</div>';
                }


                // Update unread counts after processing messages
                updateUnreadCounts(Array.from(snapshot.docs).map(doc => doc.data())); // Pass all messages from snapshot
                updateUnreadIndicators();
            }, (error) => {
                hideLoadingOverlay();
                console.error("Error listening to messages: ", error);
                showModal("Error loading messages: " + error.message, 'alert');
            });
        }


        // --- User Profile / Authentication Functions ---

        async function saveUserProfile(username) {
            if (!db) {
                console.error("Firestore not initialized for saving profile.");
                return;
            }
            try {
                showLoadingOverlay("Saving profile...");
                const userDocRef = doc(db, `artifacts/${appId}/users/${userId}/profile`, 'info');
                await setDoc(userDocRef, { username: username, lastUpdated: serverTimestamp() }, { merge: true });
                localStorage.setItem(`assembleUserName_${appId}`, username); // Persist username (rebranded)
                currentUserName = username;
                currentUserNameDisplay.textContent = currentUserName;
                currentUserAvatarDisplay.textContent = currentUserName.charAt(0).toUpperCase();

                const onlineUserRef = doc(db, `artifacts/${appId}/public/data/online_users`, userId);
                await setDoc(onlineUserRef, { username: username, lastSeen: serverTimestamp(), status: 'online' }, { merge: true });
            } catch (e) {
                console.error("Error saving user profile: ", e);
                showModal("Failed to save username: " + e.message, 'alert');
            } finally {
                hideLoadingOverlay();
            }
        }

        async function loadUserProfile() {
            if (!db) {
                console.error("Firestore not initialized for loading profile.");
                return;
            }
            const localUserName = localStorage.getItem(`assembleUserName_${appId}`); // Rebranded
            if (localUserName) {
                currentUserName = localUserName;
                currentUserNameDisplay.textContent = currentUserName;
                currentUserAvatarDisplay.textContent = currentUserName.charAt(0).toUpperCase();
                return;
            }

            try {
                showLoadingOverlay("Loading user profile...");
                const userDocRef = doc(db, `artifacts/${appId}/users/${userId}/profile`, 'info');
                const docSnap = await getDoc(userDocRef);
                if (docSnap.exists() && docSnap.data().username) {
                    currentUserName = docSnap.data().username;
                    localStorage.setItem(`assembleUserName_${appId}`, currentUserName); // Rebranded
                    currentUserNameDisplay.textContent = currentUserName;
                    currentUserAvatarDisplay.textContent = currentUserName.charAt(0).toUpperCase();
                } else {
                    promptForUsername();
                }
            } catch (e) {
                console.error("Error loading user profile: ", e);
                showModal("Failed to load user profile. Using anonymous name.", 'alert');
                promptForUsername();
            } finally {
                hideLoadingOverlay();
            }
        }

        function promptForUsername() {
            showModal(
                "Welcome to Assemble! Please enter your desired username:",
                'confirm',
                (confirmed, username) => {
                    if (confirmed && username.trim()) {
                        saveUserProfile(username.trim());
                    } else {
                        currentUserName = `Anon-${userId.substring(0, 4)}`;
                        currentUserNameDisplay.textContent = currentUserName;
                        currentUserAvatarDisplay.textContent = currentUserName.charAt(0).toUpperCase();
                        showModal("No username set. You will be an anonymous user.", 'alert');
                    }
                },
                { placeholder: "Your Assemble Username" } // Rebranded
            );
        }

        // --- Server & Channel Management with Firestore ---

        function listenForServers() {
            if (unsubscribeServers) {
                unsubscribeServers();
            }
            const serversRef = collection(db, `artifacts/${appId}/public/data/servers`);
            unsubscribeServers = onSnapshot(query(serversRef, orderBy('createdAt')), (snapshot) => { // Order by createdAt
                let firstServerId = null;
                allServers = {}; // Clear and rebuild
                snapshot.forEach(doc => {
                    const serverData = doc.data();
                    const serverId = doc.id;
                    allServers[serverId] = { id: serverId, ...serverData, channels: [] };
                    if (!firstServerId) {
                        firstServerId = serverId;
                    }
                });

                renderServerIcons();

                if (!activeServerId && firstServerId) {
                    setActiveServer(firstServerId);
                } else if (activeServerId && !allServers[activeServerId]) {
                    if (firstServerId) {
                        setActiveServer(firstServerId);
                    } else {
                        clearChatArea();
                    }
                }
            }, (error) => {
                console.error("Error listening to servers: ", error);
                showModal("Error loading servers: " + error.message, 'alert');
            });
        }

        function listenForChannels(serverId) {
            if (unsubscribeChannels) {
                unsubscribeChannels();
            }
            if (!serverId || !allServers[serverId]) {
                textChannelsContainer.innerHTML = '<div class="p-2 text-xs text-[#99aab5] text-center">No channels found.</div>';
                return;
            }

            const channelsRef = collection(db, `artifacts/${appId}/public/data/servers/${serverId}/channels`);
            unsubscribeChannels = onSnapshot(query(channelsRef, orderBy('createdAt')), (snapshot) => { // Order by createdAt
                allServers[serverId].channels = [];
                let firstChannelId = null;
                snapshot.forEach(doc => {
                    const channelData = doc.data();
                    const channelId = doc.id;
                    allServers[serverId].channels.push({ id: channelId, ...channelData });
                    if (!firstChannelId) {
                        firstChannelId = channelId;
                    }
                });

                updateChannelList(serverId);

                if (activeServerId === serverId && (!activeChannelId || !allServers[serverId].channels.some(c => c.id === activeChannelId))) {
                    if (firstChannelId) {
                        setActiveChannel(firstChannelId, serverId);
                    } else {
                        messagesContainer.innerHTML = '<div class="text-center text-[#99aab5] mt-10">No channels in this server. Create one!</div>';
                        displayedMessageIds.clear();
                    }
                }
            }, (error) => {
                console.error(`Error listening to channels for server ${serverId}: `, error);
                showModal(`Error loading channels for server ${allServers[serverId]?.name || serverId}: ` + error.message, 'alert');
            });
        }

        function renderServerIcons() {
            serverIconsContainer.innerHTML = '';
            const sortedServers = Object.values(allServers).sort((a, b) => (a.createdAt?.seconds || 0) - (b.createdAt?.seconds || 0));

            sortedServers.forEach(server => {
                const serverIcon = document.createElement('div');
                serverIcon.className = 'server-icon w-12 h-12 bg-[#36393f] rounded-full flex items-center justify-center text-xl font-bold mb-2 cursor-pointer transition-all duration-200 hover:rounded-xl hover:bg-[#42464d]';
                if (server.id === activeServerId) {
                    serverIcon.classList.remove('rounded-full', 'bg-[#36393f]');
                    serverIcon.classList.add('rounded-xl', 'bg-[#4752c4]', 'shadow-lg');
                }
                serverIcon.dataset.serverId = server.id;
                serverIcon.title = server.name;

                const iconContent = server.name.charAt(0).toUpperCase();
                serverIcon.innerHTML = `<img src="https://placehold.co/48x48/${Math.floor(Math.random()*16777215).toString(16)}/ffffff?text=${iconContent}" alt="${server.name}" class="rounded-full">`;

                serverIcon.addEventListener('click', () => setActiveServer(server.id));
                serverIconsContainer.appendChild(serverIcon);
            });
        }

        function updateChannelList(serverId) {
            const server = allServers[serverId];
            if (!server) {
                textChannelsContainer.innerHTML = '';
                return;
            }

            currentServerNameDisplay.textContent = server.name;
            textChannelsContainer.innerHTML = '';

            if (server.channels.length === 0) {
                textChannelsContainer.innerHTML = '<div class="p-2 text-xs text-[#99aab5] text-center">No channels. Click + to create one.</div>';
            }

            server.channels.forEach(channel => {
                const channelItem = document.createElement('div');
                channelItem.className = 'channel-item flex items-center p-2 rounded-md text-[#8e9297] hover:bg-[#36393f] hover:text-[#dcddde] cursor-pointer transition duration-200';
                if (channel.id === activeChannelId && activeConversationType === 'channel') {
                    channelItem.classList.add('bg-[#3e4147]', 'text-[#dcddde]', 'font-semibold');
                }
                channelItem.innerHTML = `<i class="fas fa-hashtag mr-2 text-lg"></i><span>${channel.name}</span><div class="unread-dot hidden" data-unread-key="channel_${serverId}_${channel.id}"></div>`;
                channelItem.dataset.channelId = channel.id;
                channelItem.dataset.serverId = serverId;
                channelItem.addEventListener('click', () => {
                    setActiveChannel(channel.id, serverId);
                    if (window.innerWidth <= 768) {
                        serverSidebar.classList.remove('active');
                        channelSidebar.classList.remove('active');
                    }
                });
                textChannelsContainer.appendChild(channelItem);
            });
            updateUnreadIndicators();
        }

        function setActiveChannel(channelId, serverId) {
            if (!allServers[serverId] || !allServers[serverId].channels.some(c => c.id === channelId)) {
                console.error(`Attempted to activate non-existent channel ${channelId} in server ${serverId}`);
                showModal("The selected channel does not exist.", 'alert');
                return;
            }
            if (activeChannelId === channelId && activeServerId === serverId && activeConversationType === 'channel') return;

            activeConversationType = 'channel';
            activeChannelId = channelId;
            activeServerId = serverId;
            activeDmRecipientId = null;
            activeDmRecipientName = null;

            currentChatNameDisplay.textContent = allServers[activeServerId].channels.find(c => c.id === activeChannelId).name;
            chatHeaderIcon.className = 'fas fa-hashtag text-[#99aab5] text-xl mr-2';
            messageInput.placeholder = `Message #${currentChatNameDisplay.textContent}`;
            startCallBtn.classList.add('hidden'); // Hide call button in channels

            document.querySelectorAll('.channel-item, .dm-item').forEach(item => {
                item.classList.remove('bg-[#3e4147]', 'text-[#dcddde]', 'font-semibold');
            });
            const activeChannelItem = document.querySelector(`.channel-item[data-channel-id="${activeChannelId}"][data-server-id="${activeServerId}"]`);
            if (activeChannelItem) {
                activeChannelItem.classList.add('bg-[#3e4147]', 'text-[#dcddde]', 'font-semibold');
            }

            const unreadKey = `channel_${activeServerId}_${activeChannelId}`;
            if (unreadCounts[unreadKey]) {
                unreadCounts[unreadKey] = 0;
            }
            updateUnreadIndicators();
            fetchMessages();
        }

        function setActiveServer(serverId) {
            if (!allServers[serverId]) {
                console.error(`Attempted to activate non-existent server ${serverId}`);
                showModal("The selected server does not exist.", 'alert');
                return;
            }
            if (activeServerId === serverId) return;

            activeServerId = serverId;
            listenForChannels(serverId); // This will call updateChannelList and setActiveChannel for first channel

            document.querySelectorAll('.server-icon[data-server-id]').forEach(icon => {
                icon.classList.remove('rounded-xl', 'bg-[#4752c4]', 'shadow-lg');
                icon.classList.add('rounded-full', 'bg-[#36393f]');
                if (icon.dataset.serverId === activeServerId) {
                    icon.classList.remove('rounded-full', 'bg-[#36393f]');
                    icon.classList.add('rounded-xl', 'bg-[#4752c4]', 'shadow-lg');
                }
            });

            // Ensure DM related active states are reset when switching to a server
            activeDmRecipientId = null;
            activeDmRecipientName = null;
            startCallBtn.classList.add('hidden'); // Hide call button in servers (only for DM for now)

            if (window.innerWidth <= 768) {
                serverSidebar.classList.remove('active');
                channelSidebar.classList.add('active');
            }
        }

        // --- Direct Messages Functions ---

        function updateDmList() {
            directMessagesList.innerHTML = '';

            const dmableUsers = Object.entries(onlineUsers)
                                .filter(([id, data]) => id !== userId)
                                .sort(([,a], [,b]) => a.username.localeCompare(b.username));

            if (dmableUsers.length === 0) {
                const noDmsMsg = document.createElement('div');
                noDmsMsg.className = 'p-2 text-xs text-[#99aab5] text-center';
                noDmsMsg.textContent = 'No other users online yet.';
                directMessagesList.appendChild(noDmsMsg);
                return;
            }

            dmableUsers.forEach(([dmUserId, dmUserData]) => {
                const dmUsername = dmUserData.username;
                const dmItem = document.createElement('div');
                dmItem.className = 'dm-item flex items-center p-2 rounded-md text-[#8e9297] hover:bg-[#36393f] hover:text-[#dcddde] cursor-pointer transition duration-200';
                if (dmUserId === activeDmRecipientId && activeConversationType === 'dm') {
                    dmItem.classList.add('bg-[#3e4147]', 'text-[#dcddde]', 'font-semibold');
                }
                const avatarChar = dmUsername ? dmUsername.charAt(0).toUpperCase() : '?';
                dmItem.innerHTML = `
                    <div class="w-6 h-6 rounded-full bg-[#5865f2] flex items-center justify-center text-xs font-bold text-white mr-2">${avatarChar}</div>
                    <span>${dmUsername}</span>
                    <div class="unread-dot hidden" data-unread-key="dm_${dmUserId}"></div>
                `;
                dmItem.dataset.dmUserId = dmUserId;
                dmItem.addEventListener('click', () => {
                    setActiveDm(dmUserId, dmUsername);
                    if (window.innerWidth <= 768) {
                        serverSidebar.classList.remove('active');
                        channelSidebar.classList.remove('active');
                    }
                });
                directMessagesList.appendChild(dmItem);
            });
            updateUnreadIndicators();
        }

        function setActiveDm(dmUserId, dmUsername) {
            if (activeDmRecipientId === dmUserId && activeConversationType === 'dm') return;

            activeConversationType = 'dm';
            activeDmRecipientId = dmUserId;
            activeDmRecipientName = dmUsername; // Store recipient's name
            activeServerId = null;
            activeChannelId = null;

            currentChatNameDisplay.textContent = dmUsername;
            chatHeaderIcon.className = 'fas fa-at text-[#99aab5] text-xl mr-2';
            messageInput.placeholder = `Message @${dmUsername}`;
            startCallBtn.classList.remove('hidden'); // Show call button in DMs

            document.querySelectorAll('.channel-item, .dm-item').forEach(item => {
                item.classList.remove('bg-[#3e4147]', 'text-[#dcddde]', 'font-semibold');
            });
            const activeDmItem = document.querySelector(`.dm-item[data-dm-user-id="${activeDmRecipientId}"]`);
            if (activeDmItem) {
                activeDmItem.classList.add('bg-[#3e4147]', 'text-[#dcddde]', 'font-semibold');
            }

            const unreadKey = `dm_${dmUserId}`;
            if (unreadCounts[unreadKey]) {
                unreadCounts[unreadKey] = 0;
            }
            updateUnreadIndicators();
            fetchMessages();
        }

        // --- Unread Message Indicators ---

        function updateUnreadCounts(allMessages) {
            const tempUnreadCounts = {};

            allMessages.forEach(message => {
                if (message.userId === userId) {
                    return;
                }

                let key = null;
                if (message.type === 'channel') {
                    key = `channel_${message.serverId}_${message.channelId}`;
                    if (key === `channel_${activeServerId}_${activeChannelId}` && activeConversationType === 'channel') {
                        return;
                    }
                } else if (message.type === 'dm') {
                    if ((message.senderId === userId && message.recipientId === activeDmRecipientId && activeConversationType === 'dm') ||
                        (message.recipientId === userId && message.senderId === activeDmRecipientId && activeConversationType === 'dm')) {
                        return;
                    }
                    if (message.senderId === userId) {
                        key = `dm_${message.recipientId}`;
                    } else if (message.recipientId === userId) {
                        key = `dm_${message.senderId}`;
                    }
                }

                if (key) {
                    tempUnreadCounts[key] = (tempUnreadCounts[key] || 0) + 1;
                }
            });
            unreadCounts = tempUnreadCounts;
        }


        function updateUnreadIndicators() {
            document.querySelectorAll('.channel-item .unread-dot').forEach(dot => {
                const key = dot.dataset.unreadKey;
                if (unreadCounts[key] && unreadCounts[key] > 0) {
                    dot.classList.remove('hidden');
                } else {
                    dot.classList.add('hidden');
                }
            });

            document.querySelectorAll('.dm-item .unread-dot').forEach(dot => {
                const key = dot.dataset.unreadKey;
                if (unreadCounts[key] && unreadCounts[key] > 0) {
                    dot.classList.remove('hidden');
                } else {
                    dot.classList.add('hidden');
                }
            });
        }

        // --- Firebase Initialization and User Presence ---

        async function initializeFirebase() {
            try {
                showLoadingOverlay("Initializing Assemble...");
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        currentUserIdDisplay.textContent = `ID: ${userId.substring(0, 8)}...`;
                        isAuthReady = true;

                        await loadUserProfile();

                        listenForServers();
                        listenForOnlineUsers(); // This will also trigger DM list updates
                        listenForIncomingCalls(); // Listen for incoming calls

                        const onlineUserRef = doc(db, `artifacts/${appId}/public/data/online_users`, userId);
                        await setDoc(onlineUserRef, { username: currentUserName, lastSeen: serverTimestamp(), status: 'online' }, { merge: true });

                    } else {
                        try {
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } else {
                                await signInAnonymously(auth);
                            }
                        } catch (error) {
                            console.error("Error signing in: ", error);
                            showModal("Authentication failed: " + error.message + ". Trying anonymous sign-in.", 'alert');
                            await signInAnonymously(auth);
                        }
                    }
                });
            } catch (error) {
                console.error("Error initializing Firebase: ", error);
                showModal("Failed to initialize Assemble: " + error.message, 'alert');
                hideLoadingOverlay();
            }
        }

        function listenForOnlineUsers() {
            if (unsubscribeOnlineUsers) {
                unsubscribeOnlineUsers();
            }
            const usersRef = collection(db, `artifacts/${appId}/public/data/online_users`);
            unsubscribeOnlineUsers = onSnapshot(query(usersRef), (snapshot) => {
                onlineUsers = {};
                const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
                snapshot.forEach(doc => {
                    const data = doc.data();
                    if (data.lastSeen && data.lastSeen.seconds * 1000 > fiveMinutesAgo) {
                         onlineUsers[doc.id] = { username: data.username || `Anon-${doc.id.substring(0, 4)}`, status: 'online' };
                    }
                });
                updateDmList();
                updateMemberList();
            }, (error) => {
                console.error("Error listening to online users: ", error);
            });
        }

        function updateMemberList() {
            memberListContent.innerHTML = '';
            const members = Object.values(onlineUsers).sort((a,b) => a.username.localeCompare(b.username));

            if (members.length === 0) {
                memberListContent.innerHTML = '<p class="text-[#99aab5] text-sm">No members online.</p>';
                return;
            }

            members.forEach(member => {
                const memberElement = document.createElement('div');
                memberElement.className = 'flex items-center gap-2 p-1 rounded hover:bg-[#36393f] cursor-pointer';
                const avatarChar = member.username.charAt(0).toUpperCase();
                memberElement.innerHTML = `
                    <div class="w-6 h-6 rounded-full bg-[#5865f2] flex items-center justify-center text-xs font-bold text-white">${avatarChar}</div>
                    <span class="text-white text-sm">${member.username}</span>
                `;
                memberListContent.appendChild(memberElement);
            });
        }


        // --- WebRTC Call Functionality ---

        const servers = {
            iceServers: [
                {
                    urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'],
                },
            ],
            iceCandidatePoolSize: 10,
        };

        async function startCall(recipientId, recipientName) {
            if (!userId) {
                showModal("Please log in to start a call.", 'alert');
                return;
            }
            if (!recipientId || recipientId === userId) {
                showModal("Please select a valid user to call.", 'alert');
                return;
            }

            showLoadingOverlay(`Calling ${recipientName}...`);
            callStatusMessage.textContent = `Calling ${recipientName}...`;
            videoCallContainer.classList.add('active');

            currentCallDocRef = doc(collection(db, `artifacts/${appId}/public/data/calls`));
            currentCallId = currentCallDocRef.id;

            await currentCallDocRef.set({
                callerId: userId,
                callerName: currentUserName,
                calleeId: recipientId,
                calleeName: recipientName,
                status: 'calling',
                createdAt: serverTimestamp()
            });

            // Get local media
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            localVideo.srcObject = localStream;

            // Create peer connection
            peerConnection = new RTCPeerConnection(servers);
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            remoteStream = new MediaStream();
            remoteVideo.srcObject = remoteStream;

            peerConnection.ontrack = (event) => {
                event.streams[0].getTracks().forEach(track => {
                    remoteStream.addTrack(track);
                });
            };

            // Collect ICE candidates
            peerConnection.onicecandidate = async (event) => {
                if (event.candidate) {
                    await addDoc(collection(currentCallDocRef, 'iceCandidates'), event.candidate.toJSON());
                }
            };

            // Create offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            await updateDoc(currentCallDocRef, { sdpOffer: { type: offer.type, sdp: offer.sdp } });

            // Listen for answer and ICE candidates
            listenForCallUpdates(currentCallId);
            listenForIceCandidates(currentCallId);
            hideLoadingOverlay();
        }

        async function acceptCall(callId, callerName, sdpOffer) {
            showLoadingOverlay(`Accepting call from ${callerName}...`);
            callStatusMessage.textContent = `Call with ${callerName}...`;
            videoCallContainer.classList.add('active');
            incomingCallModal.classList.add('hidden'); // Hide incoming call modal

            currentCallDocRef = doc(db, `artifacts/${appId}/public/data/calls`, callId);
            currentCallId = callId;

            // Get local media
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            localVideo.srcObject = localStream;

            // Create peer connection
            peerConnection = new RTCPeerConnection(servers);
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            remoteStream = new MediaStream();
            remoteVideo.srcObject = remoteStream;

            peerConnection.ontrack = (event) => {
                event.streams[0].getTracks().forEach(track => {
                    remoteStream.addTrack(track);
                });
            };

            // Collect ICE candidates
            peerConnection.onicecandidate = async (event) => {
                if (event.candidate) {
                    await addDoc(collection(currentCallDocRef, 'iceCandidates'), event.candidate.toJSON());
                }
            };

            // Set remote offer and create answer
            await peerConnection.setRemoteDescription(new RTCSessionDescription(sdpOffer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            await updateDoc(currentCallDocRef, { sdpAnswer: { type: answer.type, sdp: answer.sdp }, status: 'active' });

            // Listen for further call updates and ICE candidates
            listenForCallUpdates(callId);
            listenForIceCandidates(callId);
            hideLoadingOverlay();
        }

        async function hangupCall() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop());
                remoteStream = null;
            }

            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            videoCallContainer.classList.remove('active');
            callStatusMessage.textContent = ''; // Clear status

            if (currentCallDocRef) {
                try {
                    await updateDoc(currentCallDocRef, { status: 'ended' });
                    // Optional: delete call document after a delay or on refresh for cleanup
                    // await deleteDoc(currentCallDocRef);
                } catch (e) {
                    console.error("Error setting call status to ended: ", e);
                }
            }
            if (callUnsubscribe) callUnsubscribe();
            if (iceCandidatesUnsubscribe) iceCandidatesUnsubscribe();
            currentCallDocRef = null;
            currentCallId = null;
            hideLoadingOverlay();
            showModal("Call ended.", 'alert');
        }

        function listenForCallUpdates(callId) {
            if (callUnsubscribe) callUnsubscribe();
            const callRef = doc(db, `artifacts/${appId}/public/data/calls`, callId);
            callUnsubscribe = onSnapshot(callRef, async (snapshot) => {
                const callData = snapshot.data();
                if (!callData) {
                    console.log("Call document deleted or no data.");
                    hangupCall(); // Automatically hang up if call doc is gone
                    return;
                }

                if (callData.status === 'ended') {
                    if (peerConnection) { // Only hang up if not already initiated by local user
                        hangupCall();
                        showModal("Call ended by other party.", 'alert');
                    }
                } else if (callData.sdpOffer && !peerConnection.currentRemoteDescription && callData.calleeId === userId && callData.status === 'calling') {
                    // This is handled by listenForIncomingCalls initial acceptance
                    // but can be a fallback if somehow offer wasn't processed
                    // This branch might not be strictly necessary if initial offer is handled in incomingCalls listener
                } else if (callData.sdpAnswer && !peerConnection.currentRemoteDescription && callData.callerId === userId && peerConnection) {
                    // Caller receives answer
                    try {
                        const rtcSessionDescription = new RTCSessionDescription(callData.sdpAnswer);
                        await peerConnection.setRemoteDescription(rtcSessionDescription);
                        console.log("Remote answer set successfully.");
                        callStatusMessage.textContent = `Call with ${callData.calleeName || 'other party'} active.`;
                    } catch (e) {
                        console.error("Error setting remote description from answer:", e);
                        showModal("Failed to establish call (answer error): " + e.message, 'alert');
                    }
                }
            }, (error) => {
                console.error("Error listening to call document: ", error);
            });
        }

        function listenForIceCandidates(callId) {
            if (iceCandidatesUnsubscribe) iceCandidatesUnsubscribe();
            const iceCandidatesRef = collection(db, `artifacts/${appId}/public/data/calls/${callId}/iceCandidates`);
            iceCandidatesUnsubscribe = onSnapshot(query(iceCandidatesRef), (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === "added") {
                        const candidate = new RTCIceCandidate(change.doc.data());
                        try {
                            if (peerConnection && peerConnection.remoteDescription) {
                                await peerConnection.addIceCandidate(candidate);
                                console.log("ICE candidate added successfully.");
                            } else {
                                console.log("Remote description not set yet, deferring ICE candidate.");
                                // Store candidates to add later if remote description isn't ready
                            }
                        } catch (e) {
                            console.error("Error adding received ICE candidate:", e);
                            // showModal("Error processing call (ICE candidate error): " + e.message, 'alert'); // Too many alerts
                        }
                    }
                });
            }, (error) => {
                console.error("Error listening to ICE candidates: ", error);
            });
        }

        function listenForIncomingCalls() {
            if (unsubscribeIncomingCalls) unsubscribeIncomingCalls();
            const callsRef = collection(db, `artifacts/${appId}/public/data/calls`);
            unsubscribeIncomingCalls = onSnapshot(query(callsRef), (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    const callData = change.doc.data();
                    const callId = change.doc.id;

                    if (callData.calleeId === userId && callData.status === 'calling' && change.type === 'added') {
                        // Incoming call!
                        incomingCallMessage.textContent = `${callData.callerName || 'Someone'} is calling you!`;
                        incomingCallModal.classList.remove('hidden');

                        acceptCallBtn.onclick = async () => {
                            try {
                                await acceptCall(callId, callData.callerName, callData.sdpOffer);
                            } catch (e) {
                                console.error("Error accepting call:", e);
                                showModal("Failed to accept call: " + e.message, 'alert');
                                hangupCall(); // Ensure call is cleaned up
                            }
                        };
                        declineCallBtn.onclick = async () => {
                            try {
                                await updateDoc(doc(db, `artifacts/${appId}/public/data/calls`, callId), { status: 'declined' });
                                incomingCallModal.classList.add('hidden');
                                showModal("Call declined.", 'alert');
                            } catch (e) {
                                console.error("Error declining call:", e);
                                showModal("Error declining call: " + e.message, 'alert');
                            }
                        };
                    } else if (callData.callerId === userId && callData.status === 'declined' && change.type === 'modified') {
                        showModal(`${callData.calleeName || 'The other party'} declined your call.`, 'alert');
                        hangupCall(); // Clean up caller's side
                    }
                });
            }, (error) => {
                console.error("Error listening for incoming calls: ", error);
            });
        }


        // --- Event Listeners ---

        window.onload = () => {
            initializeFirebase();
            autoResizeTextarea();
            clearChatArea();
        };

        messageInput.addEventListener('input', autoResizeTextarea);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                const messageText = messageInput.value.trim();
                if (messageText.startsWith('/ai ')) {
                    const prompt = messageText.substring(4).trim();
                    if (prompt) {
                        sendMessage(messageText);
                        generateAiResponse(prompt);
                    } else {
                        showModal("Please provide a prompt for the AI (e.g., /ai tell me a joke).", 'alert');
                    }
                } else {
                    sendMessage(messageText);
                }
            }
        });

        addServerBtn.addEventListener('click', () => {
            showModal(
                "Enter new Assemble server name:",
                'confirm',
                async (confirmed, serverName) => {
                    if (confirmed && serverName.trim()) {
                        const newServerId = serverName.trim().toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-*|-*$/g, '');
                        if (newServerId.length === 0) {
                            showModal("Server name cannot be empty.", 'alert');
                            return;
                        }
                        if (allServers[newServerId]) {
                            showModal("A server with that ID already exists!", 'alert');
                            return;
                        }

                        try {
                            showLoadingOverlay("Creating server...");
                            const serverRef = doc(db, `artifacts/${appId}/public/data/servers`, newServerId);
                            await setDoc(serverRef, {
                                name: serverName.trim(),
                                createdAt: serverTimestamp(),
                                ownerId: userId
                            });

                            const channelsRef = collection(db, `artifacts/${appId}/public/data/servers/${newServerId}/channels`);
                            await addDoc(channelsRef, {
                                name: 'general',
                                type: 'text',
                                createdAt: serverTimestamp()
                            });

                            showModal(`Server "${serverName.trim()}" created!`, 'alert');
                            setActiveServer(newServerId);
                        } catch (e) {
                            console.error("Error creating server: ", e);
                            showModal("Failed to create server: " + e.message, 'alert');
                        } finally {
                            hideLoadingOverlay();
                        }
                    }
                },
                { placeholder: "e.g., My Assemble Server" }
            );
        });


        mobileMenuToggle.addEventListener('click', () => {
            serverSidebar.classList.toggle('active');
            channelSidebar.classList.toggle('active');
        });

        userSettingsBtn.addEventListener('click', () => {
            showModal(
                "Change your username:",
                'confirm',
                (confirmed, newUsername) => {
                    if (confirmed && newUsername.trim()) {
                        saveUserProfile(newUsername.trim());
                    }
                },
                { placeholder: "New Assemble Username", defaultValue: currentUserName }
            );
        });

        createChannelBtn.addEventListener('click', () => {
            if (!activeServerId) {
                showModal("Please select a server first to create a channel.", 'alert');
                return;
            }
            showModal(
                `Enter new channel name for "${allServers[activeServerId]?.name || 'this server'}":`,
                'confirm',
                async (confirmed, channelName) => {
                    if (confirmed && channelName.trim()) {
                        const newChannelId = channelName.trim().toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-*|-*$/g, '');
                        if (newChannelId.length === 0) {
                            showModal("Channel name cannot be empty.", 'alert');
                            return;
                        }
                        if (allServers[activeServerId] && allServers[activeServerId].channels.some(c => c.id === newChannelId)) {
                            showModal("A channel with that name already exists in this server!", 'alert');
                            return;
                        }

                        try {
                            showLoadingOverlay("Creating channel...");
                            const channelsCollectionRef = collection(db, `artifacts/${appId}/public/data/servers/${activeServerId}/channels`);
                            await addDoc(channelsCollectionRef, {
                                name: channelName.trim(),
                                type: 'text',
                                createdAt: serverTimestamp()
                            });
                            showModal(`Channel #${channelName.trim()} created!`, 'alert');
                        } catch (e) {
                            console.error("Error adding new channel to Firestore:", e);
                            showModal("Failed to create channel: " + e.message, 'alert');
                        } finally {
                            hideLoadingOverlay();
                        }
                    }
                },
                { placeholder: "e.g., general-chat" }
            );
        });

        memberListToggle.addEventListener('click', () => {
            memberListSidebar.classList.toggle('active');
        });

        scrollToBottomBtn.addEventListener('click', () => {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            hideScrollToBottomButton();
        });

        messagesContainer.addEventListener('scroll', () => {
            if (isUserAtBottom()) {
                hideScrollToBottomButton();
            }
        });

        // WebRTC Call Button Event Listeners
        startCallBtn.addEventListener('click', () => {
            if (activeConversationType === 'dm' && activeDmRecipientId) {
                startCall(activeDmRecipientId, activeDmRecipientName);
            } else {
                showModal("You can only start a video call in a Direct Message chat.", 'alert');
            }
        });

        hangupBtn.addEventListener('click', hangupCall);

        toggleMicBtn.addEventListener('click', () => {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = !track.enabled;
                    toggleMicBtn.querySelector('i').className = track.enabled ? 'fas fa-microphone' : 'fas fa-microphone-slash';
                });
            }
        });

        toggleCameraBtn.addEventListener('click', () => {
            if (localStream) {
                localStream.getVideoTracks().forEach(track => {
                    track.enabled = !track.enabled;
                    toggleCameraBtn.querySelector('i').className = track.enabled ? 'fas fa-video' : 'fas fa-video-slash';
                });
            }
        });


        // Generate a message using Gemini API
        async function generateAiResponse(prompt) {
            try {
                showLoadingOverlay("Generating AI response...");
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                hideLoadingOverlay();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    const aiMessageData = {
                        text: text,
                        username: 'AI Assistant',
                        userId: 'ai-assistant',
                        timestamp: serverTimestamp(),
                        type: activeConversationType
                    };
                    if (activeConversationType === 'channel') {
                        aiMessageData.channelId = activeChannelId;
                        aiMessageData.serverId = activeServerId;
                    } else if (activeConversationType === 'dm' && activeDmRecipientId) {
                        aiMessageData.senderId = 'ai-assistant';
                        aiMessageData.recipientId = userId;
                    }

                    const collectionPath = `artifacts/${appId}/public/data/messages`;
                    await addDoc(collection(db, collectionPath), aiMessageData);
                } else {
                    console.error("AI response structure unexpected:", result);
                    showModal("AI could not generate a response. Please try again.", 'alert');
                }
            } catch (error) {
                hideLoadingOverlay();
                console.error("Error calling Gemini API:", error);
                showModal("Error generating AI response: " + error.message, 'alert');
            }
        }
    </script>
</body>
</html>
